#!/usr/bin/env bash
# Consolidated benchmark script for fit implementations
source "$(dirname "$0")/lib.sh"

# Defaults
WARMUP=2
MIN_RUNS=5
BENCH_DIR=""
HYPERFINE_OPTS=()

# Subcommand-specific defaults
CMD="status"
WORKERS="8"
IMPL="rust"
WORKER_LIST="1,2,4,8,12,16"

show_help() {
    cat <<'EOF'
bench - Benchmark fit implementations

Usage: bench <subcommand> [options] [-- hyperfine-flags]

Subcommands:
  compare   Compare all implementations head-to-head
  git       Compare git commits/branches of an implementation
  scale     Test worker scaling for an implementation
  suite     Run full benchmark suite with markdown output
  help      Show this help message

Global Options:
  -h, --help              Show help
  -d, --dir DIR           Run benchmarks in DIR (default: current directory)
  -w, --warmup N          Warmup runs (default: 2)
  -m, --min-runs N        Minimum benchmark runs (default: 5)
  -i, --ignore-failure    Continue on non-zero exit codes
  --show-output           Show command stdout/stderr

compare Options:
  -c, --cmd CMD           Git command to benchmark (default: status)
  -n, --workers N         Number of workers (default: 8)

scale Options:
  -I, --impl IMPL         Implementation to test (default: rust)
  -c, --cmd CMD           Git command to benchmark (default: status)
  -n, --workers LIST      Comma-separated worker counts (default: 1,2,4,8,12,16)

git Options:
  -I, --impl IMPL         Implementation to compare (default: rust)
  -b, --baseline REF      Baseline git ref (default: main)
  -t, --target REF        Target git ref (default: HEAD)
  -c, --cmd CMD           Git command to benchmark (default: status)
  -n, --workers N         Number of workers (default: 8)

Examples:
  bench compare -d ~/src                # compare impls in ~/src directory
  bench compare -c fetch -n 4           # compare on fetch with 4 workers
  bench compare --show-output -i        # debug failures
  bench git -b main -d ~/src             # compare HEAD vs main branch
  bench git -t fix-branch -c fetch       # compare fix-branch vs main on fetch
  bench scale -I zig -n 1,2,4,8         # test zig scaling
  bench suite -d ~/src > results.md     # generate markdown report
  bench compare -- --export-json out.json
EOF
}

show_subcommand_help() {
    local subcmd="$1"
    case "$subcmd" in
        compare)
            cat <<'EOF'
bench compare - Compare all implementations head-to-head

Usage: bench compare [options] [-- hyperfine-flags]

Options:
  -c, --cmd CMD       Git command to benchmark (default: status)
  -n, --workers N     Number of workers (default: 8)

Global options (-d, -w, -m, -i, --show-output) also apply.
EOF
            ;;
        scale)
            cat <<'EOF'
bench scale - Test worker scaling for an implementation

Usage: bench scale [options] [-- hyperfine-flags]

Options:
  -I, --impl IMPL       Implementation to test (default: rust)
  -c, --cmd CMD         Git command to benchmark (default: status)
  -n, --workers LIST    Comma-separated worker counts (default: 1,2,4,8,12,16)

Global options (-d, -w, -m, -i, --show-output) also apply.
EOF
            ;;
        suite)
            cat <<'EOF'
bench suite - Run full benchmark suite with markdown output

Usage: bench suite [options]

Runs head-to-head comparisons and scaling tests for all implementations.
Output is markdown-formatted, suitable for piping to a file:

  bench suite > docs/benchmark-results.md

Global options (-d, -w, -m, -i, --show-output) also apply.
EOF
            ;;
        git)
            cat <<'EOF'
bench git - Compare git commits/branches of an implementation

Usage: bench git [options] [-- hyperfine-flags]

Builds binaries from two git refs and compares their performance.
Binaries are saved to /tmp with descriptive names (e.g., fit-rust-main-abc123).

Options:
  -I, --impl IMPL       Implementation to compare (default: rust)
  -b, --baseline REF    Baseline git ref (default: main)
  -t, --target REF      Target git ref (default: HEAD)
  -c, --cmd CMD         Git command to benchmark (default: status)
  -n, --workers N       Number of workers (default: 8)

Global options (-d, -w, -m, -i, --show-output) also apply.

Examples:
  bench git                               # compare HEAD vs main
  bench git -b v0.1.0 -t v0.2.0           # compare tagged versions
  bench git -c fetch -d ~/src/oss         # compare fetch in ~/src/oss
EOF
            ;;
    esac
}

# Handle global options that take an argument (-d, -w, -m)
parse_global_opt_with_arg() {
    case "$1" in
        -d|--dir) BENCH_DIR="$2" ;;
        -w|--warmup) WARMUP="$2" ;;
        -m|--min-runs) MIN_RUNS="$2" ;;
    esac
}

# Handle global options that are flags (-i, --show-output)
parse_global_opt_flag() {
    HYPERFINE_OPTS+=("$1")
}

cmd_compare() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help compare; exit 0 ;;
            -c|--cmd) CMD="$2"; shift 2 ;;
            -n|--workers) WORKERS="$2"; shift 2 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                echo "Use '-c CMD' to specify command (e.g., -c pull)"
                exit 1
                ;;
        esac
    done

    IMPLEMENTATIONS=($(discover_implementations))
    [[ ${#IMPLEMENTATIONS[@]} -eq 0 ]] && { echo "No implementations found in ${BIN_DIR}"; exit 1; }

    echo "=== Benchmarking: fit $CMD (workers=$WORKERS) ==="
    echo "Implementations: ${IMPLEMENTATIONS[*]}"
    echo

    CMDS=()
    for impl in "${IMPLEMENTATIONS[@]}"; do
        name=$(basename "$impl")
        if [[ -n "$BENCH_DIR" ]]; then
            CMDS+=("-n" "$name" "cd '$BENCH_DIR' && $impl -n $WORKERS $CMD")
        else
            CMDS+=("-n" "$name" "$impl -n $WORKERS $CMD")
        fi
    done

    hyperfine --warmup "$WARMUP" --min-runs "$MIN_RUNS" "${HYPERFINE_OPTS[@]}" "${CMDS[@]}"
}

cmd_scale() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help scale; exit 0 ;;
            -I|--impl) IMPL="$2"; shift 2 ;;
            -c|--cmd) CMD="$2"; shift 2 ;;
            -n|--workers) WORKER_LIST="$2"; shift 2 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                echo "Use '-I IMPL' to specify implementation (e.g., -I zig)"
                exit 1
                ;;
        esac
    done

    NIT="${BIN_DIR}/fit-${IMPL}"

    if [[ ! -x "$NIT" ]]; then
        echo "Implementation not found: $NIT"
        echo "Available: $(discover_impl_names | tr '\n' ' ')"
        exit 1
    fi

    echo "=== Worker Scaling: fit-${IMPL} $CMD ==="
    echo "Workers: $WORKER_LIST"
    echo

    local bench_cmd="$NIT -n {workers} $CMD"
    [[ -n "$BENCH_DIR" ]] && bench_cmd="cd '$BENCH_DIR' && $bench_cmd"

    hyperfine \
        --warmup "$WARMUP" \
        --min-runs "$MIN_RUNS" \
        "${HYPERFINE_OPTS[@]}" \
        -L workers "$WORKER_LIST" \
        "$bench_cmd"
}

cmd_git() {
    local BASELINE_REF="main"
    local TARGET_REF="HEAD"

    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help git; exit 0 ;;
            -I|--impl) IMPL="$2"; shift 2 ;;
            -b|--baseline) BASELINE_REF="$2"; shift 2 ;;
            -t|--target) TARGET_REF="$2"; shift 2 ;;
            -c|--cmd) CMD="$2"; shift 2 ;;
            -n|--workers) WORKERS="$2"; shift 2 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                echo "Use '-b REF' for baseline or '-t REF' for target"
                exit 1
                ;;
        esac
    done

    # Save current state
    local ORIGINAL_REF
    ORIGINAL_REF=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || git rev-parse HEAD)
    local STASHED=false

    # Check for uncommitted changes
    if ! git diff --quiet || ! git diff --cached --quiet; then
        echo "Stashing uncommitted changes..."
        git stash push -m "bench git: temporary stash"
        STASHED=true
    fi

    cleanup() {
        echo "Restoring to $ORIGINAL_REF..."
        git checkout "$ORIGINAL_REF" 2>/dev/null || true
        if [[ "$STASHED" == "true" ]]; then
            echo "Restoring stashed changes..."
            git stash pop || true
        fi
    }
    trap cleanup EXIT

    # Resolve refs to short SHAs for naming
    local BASELINE_SHA TARGET_SHA
    BASELINE_SHA=$(git rev-parse --short "$BASELINE_REF")
    TARGET_SHA=$(git rev-parse --short "$TARGET_REF")

    # Use the ref as the display name (branch name, tag, or SHA)
    # The SHA suffix in the binary path ensures uniqueness even if the ref moves
    local BASELINE_NAME="$BASELINE_REF"
    local TARGET_NAME="$TARGET_REF"

    local BASELINE_BIN="/tmp/fit-${IMPL}-${BASELINE_NAME}-${BASELINE_SHA}"
    local TARGET_BIN="/tmp/fit-${IMPL}-${TARGET_NAME}-${TARGET_SHA}"

    local IMPL_DIR
    IMPL_DIR=$(get_impl_dir "$IMPL")
    local BUILD_CMD
    BUILD_CMD=$(get_build_cmd "$IMPL")
    local BINARY_PATH
    BINARY_PATH=$(get_binary_path "$IMPL")

    echo "=== Building $IMPL binaries for comparison ==="
    echo "Baseline: $BASELINE_REF ($BASELINE_SHA)"
    echo "Target:   $TARGET_REF ($TARGET_SHA)"
    echo

    # Build baseline
    if [[ -x "$BASELINE_BIN" ]]; then
        echo "Using cached baseline: $BASELINE_BIN"
    else
        echo "Building baseline ($BASELINE_REF)..."
        git checkout "$BASELINE_REF"
        (cd "$IMPL_DIR" && $BUILD_CMD)
        cp "$BINARY_PATH" "$BASELINE_BIN"
        echo "Saved: $BASELINE_BIN"
    fi
    echo

    # Build target
    if [[ -x "$TARGET_BIN" ]]; then
        echo "Using cached target: $TARGET_BIN"
    else
        echo "Building target ($TARGET_REF)..."
        git checkout "$TARGET_REF"
        (cd "$IMPL_DIR" && $BUILD_CMD)
        cp "$BINARY_PATH" "$TARGET_BIN"
        echo "Saved: $TARGET_BIN"
    fi
    echo

    # Return to original ref before benchmarking
    git checkout "$ORIGINAL_REF"
    if [[ "$STASHED" == "true" ]]; then
        git stash pop
        STASHED=false
    fi
    trap - EXIT

    echo "=== Benchmarking: fit $CMD (workers=$WORKERS) ==="
    echo "Baseline: $BASELINE_NAME-$BASELINE_SHA"
    echo "Target:   $TARGET_NAME-$TARGET_SHA"
    echo

    local BASELINE_CMD="$BASELINE_BIN -n $WORKERS $CMD"
    local TARGET_CMD="$TARGET_BIN -n $WORKERS $CMD"
    [[ -n "$BENCH_DIR" ]] && BASELINE_CMD="cd '$BENCH_DIR' && $BASELINE_CMD"
    [[ -n "$BENCH_DIR" ]] && TARGET_CMD="cd '$BENCH_DIR' && $TARGET_CMD"

    hyperfine \
        --warmup "$WARMUP" \
        --min-runs "$MIN_RUNS" \
        "${HYPERFINE_OPTS[@]}" \
        -n "$BASELINE_NAME-$BASELINE_SHA" "$BASELINE_CMD" \
        -n "$TARGET_NAME-$TARGET_SHA" "$TARGET_CMD"
}

cmd_suite() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help) show_subcommand_help suite; exit 0 ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; break ;;
            -*) echo "Unknown option: $1"; exit 1 ;;
            *)
                echo "Unexpected argument: $1"
                exit 1
                ;;
        esac
    done

    echo "# Benchmark Results - $(date '+%Y-%m-%d')"
    echo
    echo "## Environment"
    echo
    echo "* $(uname -s) $(uname -r)"
    echo "* $(sysctl -n hw.ncpu 2>/dev/null || nproc) CPU cores"
    echo "* Implementations: $(discover_impl_names | tr '\n' ' ')"
    echo

    for cmd in status fetch; do
        echo "## $cmd - Head to Head"
        echo
        echo '```'
        CMD="$cmd" WORKERS="8" cmd_compare 2>&1
        echo '```'
        echo
    done

    echo "## Worker Scaling (status)"
    echo
    for impl in $(discover_impl_names); do
        echo "### fit-${impl}"
        echo
        echo '```'
        IMPL="$impl" CMD="status" WORKER_LIST="1,2,4,8" cmd_scale 2>&1
        echo '```'
        echo
    done
}

main() {
    # Parse global options
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                if [[ $# -eq 1 ]]; then
                    show_help
                    exit 0
                fi
                break  # Let subcommand handle its own -h
                ;;
            -d|--dir|-w|--warmup|-m|--min-runs)
                parse_global_opt_with_arg "$1" "$2"; shift 2 ;;
            -i|--ignore-failure|--show-output)
                parse_global_opt_flag "$1"; shift ;;
            --) shift; HYPERFINE_OPTS+=("$@"); break ;;
            -*)
                # Check if this is a known subcommand option, if so let subcommand handle it
                break
                ;;
            *) break ;;
        esac
    done

    SUBCOMMAND="${1:-compare}"
    shift || true

    case "$SUBCOMMAND" in
        compare) cmd_compare "$@" ;;
        git) cmd_git "$@" ;;
        scale) cmd_scale "$@" ;;
        suite) cmd_suite "$@" ;;
        help) show_help ;;
        *)
            echo "Unknown subcommand: $SUBCOMMAND"
            echo "Run 'bench help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
